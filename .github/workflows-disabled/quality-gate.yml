name: Quality Gate

on:
  pull_request:
    branches: [main, develop]
  push:
    branches: [main, develop]

permissions:
  contents: read
  actions: read
  checks: write
  pull-requests: write
  statuses: write

jobs:
  quality-metrics:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      coverage: ${{ steps.coverage.outputs.percentage }}
      complexity: ${{ steps.complexity.outputs.score }}
      maintainability: ${{ steps.maintainability.outputs.score }}
      passed: ${{ steps.evaluate.outputs.passed }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for better analysis
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pytest pytest-cov radon bandit pylint coverage
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
      
      - name: Run tests with coverage
        id: coverage
        run: |
          coverage run -m pytest || true
          coverage report
          COVERAGE=$(coverage report | grep TOTAL | awk '{print $4}' | sed 's/%//')
          echo "percentage=${COVERAGE:-0}" >> $GITHUB_OUTPUT
          
          # Generate coverage badge
          if [ "${COVERAGE:-0}" -ge 80 ]; then
            COLOR="green"
          elif [ "${COVERAGE:-0}" -ge 60 ]; then
            COLOR="yellow"
          else
            COLOR="red"
          fi
          echo "badge_color=$COLOR" >> $GITHUB_OUTPUT
      
      - name: Calculate code complexity
        id: complexity
        run: |
          # Calculate cyclomatic complexity
          radon cc . -a -j > complexity.json || echo '{"average_complexity": 10}' > complexity.json
          COMPLEXITY=$(python -c "import json; data=json.load(open('complexity.json')); print(data.get('average_complexity', 10))")
          echo "score=${COMPLEXITY}" >> $GITHUB_OUTPUT
      
      - name: Calculate maintainability index
        id: maintainability
        run: |
          # Calculate maintainability index
          radon mi . -j > maintainability.json || echo '{"mi": 50}' > maintainability.json
          MAINTAINABILITY=$(python -c "import json; data=json.load(open('maintainability.json')); print(data.get('mi', 50))")
          echo "score=${MAINTAINABILITY}" >> $GITHUB_OUTPUT
      
      - name: Security scan
        id: security
        run: |
          bandit -r . -f json -o bandit.json || true
          if [ -f bandit.json ]; then
            HIGH_ISSUES=$(python -c "import json; data=json.load(open('bandit.json')); print(len([i for i in data.get('results', []) if i.get('issue_severity') == 'HIGH']))")
            echo "high_issues=${HIGH_ISSUES:-0}" >> $GITHUB_OUTPUT
          else
            echo "high_issues=0" >> $GITHUB_OUTPUT
          fi
      
      - name: Evaluate quality gates
        id: evaluate
        run: |
          COVERAGE=${{ steps.coverage.outputs.percentage }}
          COMPLEXITY=${{ steps.complexity.outputs.score }}
          MAINTAINABILITY=${{ steps.maintainability.outputs.score }}
          HIGH_ISSUES=${{ steps.security.outputs.high_issues }}
          
          # Default values if empty
          COVERAGE=${COVERAGE:-0}
          COMPLEXITY=${COMPLEXITY:-10}
          MAINTAINABILITY=${MAINTAINABILITY:-50}
          HIGH_ISSUES=${HIGH_ISSUES:-0}
          
          # Quality gate criteria
          PASSED=true
          FAILURES=""
          
          if [ "$COVERAGE" -lt 60 ]; then
            PASSED=false
            FAILURES="${FAILURES}\n- Code coverage is below 60% (current: ${COVERAGE}%)"
          fi
          
          if (( $(echo "$COMPLEXITY > 10" | bc -l) )); then
            PASSED=false
            FAILURES="${FAILURES}\n- Code complexity is too high (current: ${COMPLEXITY})"
          fi
          
          if [ "$MAINTAINABILITY" -lt 20 ]; then
            PASSED=false
            FAILURES="${FAILURES}\n- Maintainability index is too low (current: ${MAINTAINABILITY})"
          fi
          
          if [ "$HIGH_ISSUES" -gt 0 ]; then
            PASSED=false
            FAILURES="${FAILURES}\n- High severity security issues found (count: ${HIGH_ISSUES})"
          fi
          
          echo "passed=$PASSED" >> $GITHUB_OUTPUT
          echo "failures=$FAILURES" >> $GITHUB_OUTPUT

  report:
    runs-on: ubuntu-latest
    needs: quality-metrics
    if: always()
    timeout-minutes: 5
    steps:
      - name: Create status check
        uses: actions/github-script@v7
        with:
          script: |
            const passed = '${{ needs.quality-metrics.outputs.passed }}' === 'true';
            const coverage = '${{ needs.quality-metrics.outputs.coverage }}' || '0';
            const complexity = '${{ needs.quality-metrics.outputs.complexity }}' || 'N/A';
            const maintainability = '${{ needs.quality-metrics.outputs.maintainability }}' || 'N/A';
            
            const state = passed ? 'success' : 'failure';
            const description = passed 
              ? `Quality gates passed (Coverage: ${coverage}%)`
              : `Quality gates failed - Review required`;
            
            // Create status check
            if (context.payload.pull_request) {
              await github.rest.repos.createCommitStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                sha: context.payload.pull_request.head.sha,
                state: state,
                description: description,
                context: 'quality-gate'
              });
            }
      
      - name: Comment on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const passed = '${{ needs.quality-metrics.outputs.passed }}' === 'true';
            const coverage = '${{ needs.quality-metrics.outputs.coverage }}' || '0';
            const complexity = '${{ needs.quality-metrics.outputs.complexity }}' || 'N/A';
            const maintainability = '${{ needs.quality-metrics.outputs.maintainability }}' || 'N/A';
            
            const status = passed ? '‚úÖ' : '‚ùå';
            const title = passed ? 'Quality Gates Passed' : 'Quality Gates Failed';
            
            const body = `## ${status} ${title}
            
            ### üìä Quality Metrics
            
            | Metric | Value | Threshold | Status |
            |--------|-------|-----------|--------|
            | Code Coverage | ${coverage}% | ‚â• 60% | ${coverage >= 60 ? '‚úÖ' : '‚ùå'} |
            | Complexity | ${complexity} | ‚â§ 10 | ${complexity <= 10 ? '‚úÖ' : '‚ùå'} |
            | Maintainability | ${maintainability} | ‚â• 20 | ${maintainability >= 20 ? '‚úÖ' : '‚ùå'} |
            
            ### üìã Quality Gate Criteria
            - [${coverage >= 60 ? 'x' : ' '}] Code coverage must be at least 60%
            - [${complexity <= 10 ? 'x' : ' '}] Average complexity must not exceed 10
            - [${maintainability >= 20 ? 'x' : ' '}] Maintainability index must be at least 20
            - [x] No high-severity security issues
            
            ${!passed ? '### ‚ö†Ô∏è Action Required\n\nThis PR does not meet the quality standards. Please address the failing criteria before merging.' : '### ‚ú® Good to merge\n\nAll quality gates have passed. This PR meets the project quality standards.'}
            
            ---
            *Quality gate evaluation completed at ${new Date().toISOString()}*`;
            
            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('Quality Gates')
            );
            
            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: body
              });
            }

  enforce-standards:
    runs-on: ubuntu-latest
    needs: quality-metrics
    if: needs.quality-metrics.outputs.passed != 'true'
    timeout-minutes: 5
    steps:
      - name: Block merge if quality gates fail
        uses: actions/github-script@v7
        with:
          script: |
            if (context.payload.pull_request) {
              // Add label to indicate quality issues
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                labels: ['quality-gate-failed']
              });
              
              // Create a failing check to block merge
              await github.rest.checks.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                name: 'Quality Gate Status',
                head_sha: context.payload.pull_request.head.sha,
                status: 'completed',
                conclusion: 'failure',
                output: {
                  title: 'Quality gates not met',
                  summary: 'This PR does not meet the minimum quality standards.',
                  text: 'Please review the quality gate report and address the failing criteria.'
                }
              });
            }