name: Continuous Monitoring

on:
  schedule:
    - cron: '*/15 * * * *'  # Every 15 minutes
  workflow_dispatch:
    inputs:
      check_type:
        description: 'Type of monitoring check'
        required: false
        default: 'all'
        type: choice
        options:
          - all
          - performance
          - health
          - workflows

permissions:
  contents: read
  actions: read
  issues: write
  pull-requests: read

jobs:
  workflow-health:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      health_score: ${{ steps.calculate.outputs.score }}
      issues_found: ${{ steps.calculate.outputs.issues }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Analyze workflow runs
        id: analyze
        uses: actions/github-script@v7
        with:
          script: |
            const now = new Date();
            const oneDayAgo = new Date(now - 24 * 60 * 60 * 1000);
            
            // Get recent workflow runs
            const { data: runs } = await github.rest.actions.listWorkflowRunsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              created: `>${oneDayAgo.toISOString()}`,
              per_page: 100
            });
            
            // Calculate metrics
            const metrics = {
              total: runs.workflow_runs.length,
              successful: 0,
              failed: 0,
              cancelled: 0,
              in_progress: 0,
              avg_duration: 0,
              long_running: []
            };
            
            let totalDuration = 0;
            let completedRuns = 0;
            
            for (const run of runs.workflow_runs) {
              switch (run.status) {
                case 'completed':
                  if (run.conclusion === 'success') metrics.successful++;
                  else if (run.conclusion === 'failure') metrics.failed++;
                  else if (run.conclusion === 'cancelled') metrics.cancelled++;
                  
                  // Calculate duration
                  const duration = new Date(run.updated_at) - new Date(run.created_at);
                  totalDuration += duration;
                  completedRuns++;
                  
                  // Flag long-running workflows (> 30 minutes)
                  if (duration > 30 * 60 * 1000) {
                    metrics.long_running.push({
                      name: run.name,
                      duration: Math.round(duration / 60000)
                    });
                  }
                  break;
                case 'in_progress':
                  metrics.in_progress++;
                  break;
              }
            }
            
            metrics.avg_duration = completedRuns > 0 ? Math.round(totalDuration / completedRuns / 60000) : 0;
            metrics.success_rate = metrics.total > 0 ? (metrics.successful / metrics.total * 100).toFixed(1) : 0;
            
            core.setOutput('metrics', JSON.stringify(metrics));
            
            console.log('Workflow Health Metrics:');
            console.log(`- Total runs: ${metrics.total}`);
            console.log(`- Success rate: ${metrics.success_rate}%`);
            console.log(`- Average duration: ${metrics.avg_duration} minutes`);
            console.log(`- Failed runs: ${metrics.failed}`);
            console.log(`- In progress: ${metrics.in_progress}`);
      
      - name: Calculate health score
        id: calculate
        uses: actions/github-script@v7
        with:
          script: |
            const metrics = JSON.parse('${{ steps.analyze.outputs.metrics }}');
            const issues = [];
            let score = 100;
            
            // Deduct points for issues
            if (metrics.success_rate < 90) {
              score -= 20;
              issues.push(`Low success rate: ${metrics.success_rate}%`);
            }
            
            if (metrics.failed > 5) {
              score -= 15;
              issues.push(`High failure count: ${metrics.failed}`);
            }
            
            if (metrics.avg_duration > 20) {
              score -= 10;
              issues.push(`Slow average runtime: ${metrics.avg_duration} minutes`);
            }
            
            if (metrics.long_running.length > 0) {
              score -= 5;
              issues.push(`${metrics.long_running.length} long-running workflows detected`);
            }
            
            core.setOutput('score', score);
            core.setOutput('issues', JSON.stringify(issues));
            
            // Create summary
            let summary = `## 📊 Workflow Health Report
            
            **Health Score:** ${score}/100 ${score >= 80 ? '✅' : score >= 60 ? '⚠️' : '❌'}
            
            ### Metrics (Last 24 Hours)
            - **Total Runs:** ${metrics.total}
            - **Success Rate:** ${metrics.success_rate}%
            - **Failed Runs:** ${metrics.failed}
            - **Average Duration:** ${metrics.avg_duration} minutes
            `;
            
            if (issues.length > 0) {
              summary += `
            ### Issues Detected
            ${issues.map(i => `- ${i}`).join('\n')}`;
            }
            
            if (metrics.long_running.length > 0) {
              summary += `
            ### Long-Running Workflows
            ${metrics.long_running.map(w => `- ${w.name}: ${w.duration} minutes`).join('\n')}`;
            }
            
            // Write to step summary
            await core.summary
              .addRaw(summary)
              .write();

  performance-monitoring:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v4
      
      - name: Check repository size
        id: repo_size
        run: |
          # Get repository size
          REPO_SIZE=$(du -sh . | cut -f1)
          echo "size=$REPO_SIZE" >> $GITHUB_OUTPUT
          
          # Check for large files
          find . -type f -size +10M -exec ls -lh {} \; > large_files.txt || true
          
          if [ -s large_files.txt ]; then
            echo "Large files detected:"
            cat large_files.txt
            echo "has_large_files=true" >> $GITHUB_OUTPUT
          else
            echo "has_large_files=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Analyze code metrics
        run: |
          # Count lines of code
          echo "## Code Metrics" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Python files
          if ls *.py 2>/dev/null || ls **/*.py 2>/dev/null; then
            PY_FILES=$(find . -name "*.py" -type f | wc -l)
            PY_LINES=$(find . -name "*.py" -type f -exec cat {} \; | wc -l)
            echo "- Python files: $PY_FILES" >> $GITHUB_STEP_SUMMARY
            echo "- Python lines: $PY_LINES" >> $GITHUB_STEP_SUMMARY
          fi
          
          # YAML files
          YAML_FILES=$(find .github/workflows -name "*.yml" -o -name "*.yaml" | wc -l)
          echo "- Workflow files: $YAML_FILES" >> $GITHUB_STEP_SUMMARY
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Repository size:** ${{ steps.repo_size.outputs.size }}" >> $GITHUB_STEP_SUMMARY

  resource-monitoring:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Check API rate limits
        uses: actions/github-script@v7
        with:
          script: |
            // Check GitHub API rate limit
            const { data: rateLimit } = await github.rest.rateLimit.get();
            
            const core_limit = rateLimit.resources.core;
            const actions_limit = rateLimit.resources.actions_runner_registration;
            
            const core_usage = ((core_limit.limit - core_limit.remaining) / core_limit.limit * 100).toFixed(1);
            const reset_time = new Date(core_limit.reset * 1000).toLocaleTimeString();
            
            console.log(`GitHub API Rate Limit:`);
            console.log(`- Used: ${core_limit.limit - core_limit.remaining}/${core_limit.limit} (${core_usage}%)`);
            console.log(`- Remaining: ${core_limit.remaining}`);
            console.log(`- Resets at: ${reset_time}`);
            
            // Warn if approaching limit
            if (core_usage > 80) {
              core.warning(`GitHub API rate limit usage is high: ${core_usage}%`);
            }
      
      - name: Check workflow minutes usage
        uses: actions/github-script@v7
        with:
          script: |
            // This would typically interface with billing API
            // For now, we'll create a placeholder report
            
            const report = `## 📊 Resource Usage Report
            
            ### GitHub Actions Minutes
            - Monthly allocation: 2000 minutes (free tier)
            - Estimated usage: Check Settings > Billing
            
            ### Storage Usage
            - Repository size: ${{ steps.repo_size.outputs.size || 'Unknown' }}
            - Artifacts: Check Actions > Management
            
            ### Recommendations
            - Enable artifact cleanup after 7 days
            - Use concurrency limits to prevent parallel runs
            - Cache dependencies to reduce build time
            `;
            
            await core.summary
              .addRaw(report)
              .write();

  alert-on-issues:
    runs-on: ubuntu-latest
    needs: [workflow-health, performance-monitoring]
    if: always() && (needs.workflow-health.outputs.health_score < 70 || failure())
    timeout-minutes: 5
    steps:
      - name: Create monitoring alert
        uses: actions/github-script@v7
        with:
          script: |
            const healthScore = ${{ needs.workflow-health.outputs.health_score || 100 }};
            const issues = JSON.parse('${{ needs.workflow-health.outputs.issues || '[]' }}');
            
            // Check for existing monitoring issue
            const { data: existingIssues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'monitoring-alert',
              per_page: 1
            });
            
            const title = '🚨 Monitoring Alert: System Health Degraded';
            const body = `## System Health Alert
            
            The continuous monitoring system has detected issues that require attention.
            
            **Health Score:** ${healthScore}/100
            **Timestamp:** ${new Date().toISOString()}
            
            ### Issues Detected
            ${issues.map(issue => `- ${issue}`).join('\n')}
            
            ### Recommended Actions
            1. Review recent workflow failures
            2. Check for performance bottlenecks
            3. Verify resource usage is within limits
            4. Run manual diagnostics if needed
            
            ### Monitoring Dashboard
            - [Workflow runs](https://github.com/${context.repo.owner}/${context.repo.repo}/actions)
            - [Resource usage](https://github.com/${context.repo.owner}/${context.repo.repo}/settings/billing)
            - [Security alerts](https://github.com/${context.repo.owner}/${context.repo.repo}/security)
            
            ---
            *This alert was generated by the continuous monitoring system.*`;
            
            if (existingIssues.length === 0 && healthScore < 70) {
              // Create new issue
              const issue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                labels: ['monitoring-alert', 'needs-attention', 'autofix']
              });
              
              console.log('Monitoring alert issue created');
              
              // Trigger self-healing workflow if critical
              if (healthScore < 50) {
                await github.rest.repos.createDispatchEvent({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  event_type: 'workflow-failure',
                  client_payload: {
                    source: 'continuous-monitoring',
                    health_score: healthScore,
                    issues: issues,
                    issue_number: issue.data.number
                  }
                });
                console.log('Triggered self-healing workflow due to critical health score');
              }
            } else if (existingIssues.length > 0) {
              // Update existing issue with comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existingIssues[0].number,
                body: `## 🔄 Updated Alert
                
                **Health Score:** ${healthScore}/100
                **Time:** ${new Date().toISOString()}
                
                ### Current Issues
                ${issues.map(issue => `- ${issue}`).join('\n')}`
              });
              
              console.log('Updated existing monitoring alert');
            }