name: Self-Healing System

on:
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to fix'
        required: false
        type: string
      error_type:
        description: 'Type of error'
        required: false
        type: choice
        options:
          - ci_failure
          - test_failure
          - dependency_error
          - api_error
          - permission_error
  schedule:
    # Run every hour to check for issues
    - cron: '0 * * * *'

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: write

jobs:
  detect-and-heal:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: $\{\{{ secrets.GITHUB_TOKEN \}\}}
    
    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.12'
    
    - name: Detect issues from open issues
      id: detect
      uses: actions/github-script@v7
      with:
        script: |
          const { data: issues } = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            labels: 'auto-generated,ci-failure',
            state: 'open',
            sort: 'created',
            direction: 'desc',
            per_page: 5
          });
          
          if (issues.length > 0) {
            console.log('Found ' + issues.length + ' open CI failure issues');
            return issues.map(i => ({
              number: i.number,
              title: i.title,
              body: i.body
            }));
          }
          return [];
    
    - name: Analyze and fix issues
      if: steps.detect.outputs.result != '[]'
      run: |
        echo "Starting self-healing process..."
        
        # Fix 1: Update dependencies
        if grep -q "ModuleNotFoundError\|ImportError" <<< "$\{\{{ steps.detect.outputs.result \}\}}"; then
          echo "Fixing missing dependencies..."
          if [ -f "requirements.txt" ]; then
            pip install --upgrade pip
            pip install -r requirements.txt --no-cache-dir
            
            # Check for missing packages and add them
            python3 << 'EOF'
        import ast
        import os
        import subprocess
        
        # Find all imports in Python files
        imports = set()
        for root, dirs, files in os.walk('src'):
            for file in files:
                if file.endswith('.py'):
                    try:
                        with open(os.path.join(root, file), 'r') as f:
                            tree = ast.parse(f.read())
                            for node in ast.walk(tree):
                                if isinstance(node, ast.Import):
                                    for alias in node.names:
                                        imports.add(alias.name.split('.')[0])
                                elif isinstance(node, ast.ImportFrom):
                                    if node.module:
                                        imports.add(node.module.split('.')[0])
                    except:
                        pass
        
        # Check which are missing
        for imp in imports:
            try:
                __import__(imp)
            except ImportError:
                print(f"Missing: {imp}")
                subprocess.run(['pip', 'install', imp], capture_output=True)
        EOF
          fi
        fi
        
        # Fix 2: Environment configuration
        if grep -q "KeyError\|EnvironmentError" <<< "$\{\{{ steps.detect.outputs.result \}\}}"; then
          echo "Fixing environment configuration..."
          if [ ! -f ".env" ] && [ -f ".env.example" ]; then
            cp .env.example .env
            echo "Created .env from example"
          fi
          
          # Add placeholder values for missing env vars
          if [ -f ".env" ]; then
            grep -E "^[A-Z_]+=" .env.example 2>/dev/null | while read -r line; do
              var_name=$(echo "$line" | cut -d'=' -f1)
              if ! grep -q "^$var_name=" .env; then
                echo "$var_name=placeholder_value" >> .env
                echo "Added missing env var: $var_name"
              fi
            done
          fi
        fi
        
        # Fix 3: File permissions
        echo "Fixing file permissions..."
        find . -type f -name "*.sh" -exec chmod +x {} \;
        find . -type f -name "*.py" -exec chmod +r {} \;
        
        # Fix 4: API errors
        if grep -q "403\|401\|API" <<< "$\{\{{ steps.detect.outputs.result \}\}}"; then
          echo "Checking API configurations..."
          python3 << 'EOF'
        import json
        import os
        
        # Check config.json for API settings
        if os.path.exists('config/config.json'):
            with open('config/config.json', 'r') as f:
                config = json.load(f)
            
            # Ensure rate limits are set
            if 'api_limits' not in config:
                config['api_limits'] = {}
            
            defaults = {
                'newsapi': {'daily_limit': 1000, 'rate_limit': 500},
                'deepl': {'monthly_limit': 500000, 'batch_size': 50},
                'claude': {'daily_limit': 1000, 'concurrent': 5}
            }
            
            for api, limits in defaults.items():
                if api not in config['api_limits']:
                    config['api_limits'][api] = limits
            
            with open('config/config.json', 'w') as f:
                json.dump(config, f, indent=2)
            print("Updated API rate limits in config")
        EOF
        fi
    
    - name: Create fix branch and PR
      if: steps.detect.outputs.result != '[]'
      uses: actions/github-script@v7
      with:
        script: |
          const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
          const branchName = 'auto-fix/ci-issues-' + timestamp + '';
          
          // Create branch
          try {
            const { data: ref } = await github.rest.git.getRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: 'heads/main'
            });
            
            await github.rest.git.createRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: 'refs/heads/' + branchName + '',
              sha: ref.object.sha
            });
            
            // Create PR
            const { data: pr } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ðŸ”§ Auto-fix: Resolve CI/CD failures`,
              head: branchName,
              base: 'main',
              body: '## ðŸ¤– Automated Fix\n              \n              This PR was automatically created to fix CI/CD failures.\n              \n              ### Fixes Applied:\n              - âœ… Updated missing dependencies\n              - âœ… Fixed environment configuration\n              - âœ… Corrected file permissions\n              - âœ… Updated API rate limits\n              \n              ### Related Issues:\n              ' + JSON.parse('$\{\{{ steps.detect.outputs.result  + '\}\}').map(i => '- Fixes #$\{\{i.number\}\}`).join('\n')}
              
              ---
              *Generated by Self-Healing System*`,
              labels: ['auto-generated', 'bug-fix']
            });
            
            console.log('Created PR #' + pr.number + '');
            
            // Comment on related issues
            const issues = JSON.parse('$\{\{{ steps.detect.outputs.result \}\}}');
            for (const issue of issues) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: 'ðŸ”§ A fix has been automatically generated in PR #' + pr.number + ''
              });
            }
          } catch (e) {
            console.log('Could not create PR:', e);
          }
    
    - name: Close resolved issues
      uses: actions/github-script@v7
      with:
        script: |
          const { data: issues } = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            labels: 'auto-generated,resolved',
            state: 'open'
          });
          
          for (const issue of issues) {
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              state: 'closed',
              state_reason: 'completed'
            });
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: 'âœ… This issue has been automatically resolved by the self-healing system.'
            });
          }