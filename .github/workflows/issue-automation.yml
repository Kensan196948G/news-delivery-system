name: Issue Automation

on:
  issues:
    types: [opened, edited, labeled, unlabeled]
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      command:
        description: 'å®Ÿè¡Œã‚³ãƒãƒ³ãƒ‰'
        required: true
        type: choice
        options:
        - analyze
        - repair
        - merge
        - close
        - escalate

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: write

jobs:
  auto-triage:
    runs-on: ubuntu-latest
    if: github.event.action == 'opened'
    
    steps:
    - name: Auto-triage New Issues
      uses: actions/github-script@v7
      with:
        script: |
          const { context } = require('@actions/github');
          const issue = context.payload.issue;
          
          let labels = [];
          let assignees = [];
          
          // Analyze issue title and body for automatic labeling
          const title = issue.title.toLowerCase();
          const body = (issue.body || '').toLowerCase();
          const content = `${title} ${body}`;
          
          // Auto-labeling based on keywords
          if (content.includes('bug') || content.includes('error') || content.includes('broken')) {
            labels.push('bug');
          }
          if (content.includes('feature') || content.includes('enhancement') || content.includes('improve')) {
            labels.push('enhancement');
          }
          if (content.includes('documentation') || content.includes('docs') || content.includes('readme')) {
            labels.push('documentation');
          }
          if (content.includes('security') || content.includes('vulnerability') || content.includes('cve')) {
            labels.push('security');
          }
          if (content.includes('ci/cd') || content.includes('github actions') || content.includes('workflow')) {
            labels.push('ci/cd');
          }
          if (content.includes('setup') || content.includes('installation') || content.includes('configuration')) {
            labels.push('setup');
          }
          
          // Priority labeling
          if (content.includes('urgent') || content.includes('critical') || content.includes('security')) {
            labels.push('priority/high');
          } else if (content.includes('important') || content.includes('soon')) {
            labels.push('priority/medium');
          } else {
            labels.push('priority/low');
          }
          
          // Apply labels
          if (labels.length > 0) {
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              labels: labels
            });
          }
          
          // Auto-assign based on issue type
          if (labels.includes('security')) {
            assignees.push(context.repo.owner);
          }
          
          if (assignees.length > 0) {
            await github.rest.issues.addAssignees({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              assignees: assignees
            });
          }
          
          // Add welcome comment with guidance
          const welcomeComment = [
            'ğŸ‘‹ Thanks for opening this issue!',
            '',
            'ğŸ¤– **Auto-triage results:**',
            labels.length > 0 ? `- Labels added: ${labels.join(', ')}` : '- No automatic labels applied',
            assignees.length > 0 ? `- Auto-assigned to: ${assignees.join(', ')}` : '',
            '',
            'ğŸ“‹ **Next steps:**',
            '- A maintainer will review this issue shortly',
            '- Please ensure all required information is provided',
            '- Check if similar issues already exist',
            '',
            'ğŸ’¡ **Tips:**',
            '- Add `[HIGH PRIORITY]` to title for urgent issues',
            '- Include steps to reproduce for bugs',
            '- Provide examples for feature requests'
          ].filter(line => line !== undefined).join('\n');

          await github.rest.issues.createComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: issue.number,
            body: welcomeComment
          });

  auto-close-stale:
    runs-on: ubuntu-latest
    if: github.event.action == 'labeled' && contains(github.event.label.name, 'stale')
    
    steps:
    - name: Auto-close Stale Issues
      uses: actions/github-script@v7
      with:
        script: |
          const { context } = require('@actions/github');
          const issue = context.payload.issue;
          
          // Check if issue has been inactive for 7 days after stale label
          const now = new Date();
          const labeledDate = new Date(context.payload.label.created_at || now);
          const daysSinceLabeled = (now - labeledDate) / (1000 * 60 * 60 * 24);
          
          if (daysSinceLabeled >= 7) {
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              state: 'closed'
            });
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: 'ğŸ¤– This issue has been automatically closed due to inactivity. If this issue is still relevant, please reopen it or create a new issue with updated information.'
            });
          }

  duplicate-detector:
    runs-on: ubuntu-latest
    if: github.event.action == 'opened'
    
    steps:
    - name: Detect Duplicate Issues
      uses: actions/github-script@v7
      with:
        script: |
          const { context } = require('@actions/github');
          const issue = context.payload.issue;
          
          // Search for similar issues
          const query = `repo:${context.repo.owner}/${context.repo.repo} is:issue "${issue.title.substring(0, 50)}"`;
          
          const { data: searchResults } = await github.rest.search.issuesAndPullRequests({
            q: query,
            sort: 'relevance',
            order: 'desc'
          });
          
          // Filter out current issue and find potential duplicates
          const potentialDuplicates = searchResults.items
            .filter(item => item.number !== issue.number && item.state === 'open')
            .slice(0, 3);
          
          if (potentialDuplicates.length > 0) {
            const duplicateList = potentialDuplicates
              .map(item => `- #${item.number}: ${item.title}`)
              .join('\n');
            
            const comment = 'ğŸ” **Potential duplicate issues detected:**\n\n' +
              duplicateList + '\n\n' +
              'Please check if your issue is already covered by one of the above. If this is a different issue, please provide more specific details to help distinguish it.\n\n' +
              'If this is indeed a duplicate, please:\n' +
              '1. Add your use case details to the existing issue\n' +
              '2. Close this issue\n' +
              '3. Subscribe to the existing issue for updates';

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: comment
            });
            
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              labels: ['needs-triage']
            });
          }

  auto-link-pr:
    runs-on: ubuntu-latest
    if: github.event.action == 'opened' && contains(github.event.issue.body, 'fix #')
    
    steps:
    - name: Auto-link PRs to Issues
      uses: actions/github-script@v7
      with:
        script: |
          const { context } = require('@actions/github');
          const issue = context.payload.issue;
          
          // Extract issue numbers from PR body
          const issueNumbers = [...(issue.body || '').matchAll(/(?:fix|fixes|close|closes)\s+#(\d+)/gi)]
            .map(match => parseInt(match[1]));
          
          if (issueNumbers.length > 0) {
            const linkedIssues = issueNumbers.map(num => `#${num}`).join(', ');
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: `ğŸ”— This issue is linked to: ${linkedIssues}\n\nğŸ¤– Automatic linking detected. This issue will be closed when the linked PR is merged.`
            });
          }

  command-processor:
    runs-on: ubuntu-latest
    if: github.event.action == 'created' && github.event.issue
    
    steps:
    - name: Process Issue Commands
      uses: actions/github-script@v7
      with:
        script: |
          const { context } = require('@actions/github');
          const comment = context.payload.comment;
          const issue = context.payload.issue;
          
          // Only process commands from repo owner or collaborators
          const { data: permission } = await github.rest.repos.getCollaboratorPermissionLevel({
            owner: context.repo.owner,
            repo: context.repo.repo,
            username: comment.user.login
          });
          
          if (!['admin', 'write'].includes(permission.permission)) {
            return;
          }
          
          const body = comment.body.trim();
          
          // Process commands
          if (body.startsWith('/label ')) {
            const labels = body.substring(7).split(' ').filter(l => l.length > 0);
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              labels: labels
            });
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: `ğŸ¤– Added labels: ${labels.join(', ')}`
            });
          }
          
          if (body === '/close') {
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              state: 'closed'
            });
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: 'ğŸ¤– Issue closed by command'
            });
          }
          
          if (body.startsWith('/assign ')) {
            const assignee = body.substring(8).trim().replace('@', '');
            await github.rest.issues.addAssignees({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              assignees: [assignee]
            });
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: `ğŸ¤– Assigned to @${assignee}`
            });
          }
          
          // ğŸ”„ é‹ç”¨ã‚µã‚¤ã‚¯ãƒ«ç”¨ã‚³ãƒãƒ³ãƒ‰
          if (body === '/analyze') {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: 'ğŸ” **è©³ç´°åˆ†æå®Ÿè¡Œä¸­...**\n\n' +
                '**å®Ÿè¡Œæ™‚åˆ»**: ' + new Date().toLocaleString('ja-JP') + '\n' +
                '**åˆ†æã‚¿ã‚¤ãƒ—**: è‡ªå‹•ã‚·ã‚¹ãƒ†ãƒ åˆ†æ\n\n' +
                'ğŸ“Š åˆ†æé …ç›®:\n' +
                '- âœ… ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ç¢ºèª\n' +
                '- âœ… ã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ†æ\n' +
                '- âœ… ä¾å­˜é–¢ä¿‚ãƒã‚§ãƒƒã‚¯\n' +
                '- âœ… ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³\n\n' +
                'â° åˆ†æå®Œäº†äºˆå®š: 2-3åˆ†å¾Œ\n\n' +
                'ğŸ¤– **è‡ªå‹•åˆ†æã‚·ã‚¹ãƒ†ãƒ **'
            });
            
            // è‡ªå‹•ä¿®å¾©ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚’åˆ†æãƒ¢ãƒ¼ãƒ‰ã§å®Ÿè¡Œ
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'auto-repair-cycle.yml',
              ref: 'main',
              inputs: {
                repair_type: 'auto'
              }
            });
          }
          
          if (body === '/repair') {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: `ğŸ”§ **è‡ªå‹•ä¿®å¾©å®Ÿè¡Œä¸­...**
              
**é–‹å§‹æ™‚åˆ»**: ${new Date().toLocaleString('ja-JP')}
**ä¿®å¾©ãƒ¢ãƒ¼ãƒ‰**: ç·Šæ€¥è‡ªå‹•ä¿®å¾©

âš¡ ä¿®å¾©å†…å®¹:
- ğŸ”„ ä¾å­˜é–¢ä¿‚ä¿®å¾©
- ğŸ“ ã‚³ãƒ¼ãƒ‰å“è³ªæ”¹å–„
- ğŸ›¡ï¸ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å•é¡Œè§£æ±º
- ğŸ“ è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«å¾©å…ƒ

ğŸ“ ä¿®å¾©å®Œäº†å¾Œã€è‡ªå‹•PRä½œæˆäºˆå®š

ğŸ¤– **è‡ªå‹•ä¿®å¾©ã‚·ã‚¹ãƒ†ãƒ **`
            });
            
            // ç·Šæ€¥ä¿®å¾©ãƒ¢ãƒ¼ãƒ‰ã§å®Ÿè¡Œ
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'auto-repair-cycle.yml',
              ref: 'main',
              inputs: {
                repair_type: 'emergency'
              }
            });
          }
          
          if (body === '/merge') {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: `ğŸ”„ **è‡ªå‹•ãƒãƒ¼ã‚¸æ‰¿èª**
              
é–¢é€£ã™ã‚‹è‡ªå‹•ä¿®å¾©PRã®æ‰¿èªãƒ»ãƒãƒ¼ã‚¸ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚

âœ… **æ‰¿èªæ¸ˆã¿**: è‡ªå‹•ä¿®å¾©å†…å®¹
âš¡ **ãƒãƒ¼ã‚¸å®Ÿè¡Œ**: å“è³ªãƒã‚§ãƒƒã‚¯é€šéå¾Œ
ğŸš€ **ãƒ‡ãƒ—ãƒ­ã‚¤**: è‡ªå‹•å®Ÿè¡Œ

ğŸ¤– **è‡ªå‹•é‹ç”¨ã‚µã‚¤ã‚¯ãƒ«**`
            });
          }
          
          if (body === '/close') {
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              state: 'closed'
            });
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: `âœ… **Issueè§£æ±ºãƒ»è‡ªå‹•ã‚¯ãƒ­ãƒ¼ã‚º**
              
**è§£æ±ºæ™‚åˆ»**: ${new Date().toLocaleString('ja-JP')}
**è§£æ±ºæ–¹æ³•**: è‡ªå‹•é‹ç”¨ã‚µã‚¤ã‚¯ãƒ«å®Œäº†

ğŸ”„ **å®Œäº†ã—ãŸé‹ç”¨ã‚µã‚¤ã‚¯ãƒ«**:
\`\`\`
âœ… ã‚¨ãƒ©ãƒ¼æ¤œçŸ¥(30åˆ†ãŠã) â†’ âœ… è‡ªå‹•ä¿®å¾© â†’ âœ… PRä½œæˆ â†’ âœ… ãƒ¬ãƒ“ãƒ¥ãƒ¼ â†’ âœ… ãƒãƒ¼ã‚¸ â†’ âœ… ãƒ‡ãƒ—ãƒ­ã‚¤
          â†“
âœ… Issueè‡ªå‹•ä½œæˆ â†’ âœ… åˆ†æãƒ»å¿œç­” â†’ âœ… ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œ â†’ âœ… [è§£æ±º] â†’ âœ… è‡ªå‹•ã‚¯ãƒ­ãƒ¼ã‚º
\`\`\`

ğŸ¯ **è‡ªå‹•åŒ–åŠ¹æœé”æˆ**: äººé–“ã®ç›£è¦–ãªã—ã§å•é¡Œè§£æ±ºå®Œäº†

ğŸ¤– **å®Œå…¨è‡ªå‹•é‹ç”¨ã‚·ã‚¹ãƒ†ãƒ **`
            });
          }
          
          if (body === '/escalate') {
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              labels: ['escalated', 'needs-human-review', 'priority/high']
            });
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: `ğŸš¨ **äººé–“ãƒ¬ãƒ“ãƒ¥ãƒ¼è¦æ±‚**
              
**ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ™‚åˆ»**: ${new Date().toLocaleString('ja-JP')}
**ç†ç”±**: è‡ªå‹•ä¿®å¾©ã§ã¯è§£æ±ºå›°é›£

âš ï¸ **äººé–“ã®ä»‹å…¥ãŒå¿…è¦**:
- è¤‡é›‘ãªè¨­è¨ˆåˆ¤æ–­ãŒå¿…è¦
- è‡ªå‹•ä¿®å¾©ã§è§£æ±ºã§ããªã„å•é¡Œ
- ãƒ“ã‚¸ãƒã‚¹è¦ä»¶ã«é–¢ã‚ã‚‹åˆ¤æ–­

ğŸ‘¥ **æ‹…å½“è€…ã‚¢ã‚µã‚¤ãƒ³**: è‡ªå‹•å®Ÿè¡Œ
ğŸ“§ **é€šçŸ¥**: é–¢ä¿‚è€…ã«é€ä¿¡

ğŸ¤– **è‡ªå‹•ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚·ã‚¹ãƒ†ãƒ **`
            });
            
            // ã‚ªãƒ¼ãƒŠãƒ¼ã«è‡ªå‹•ã‚¢ã‚µã‚¤ãƒ³
            await github.rest.issues.addAssignees({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              assignees: [context.repo.owner]
            });
          }
          }