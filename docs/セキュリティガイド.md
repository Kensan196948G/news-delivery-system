# 🔒 セキュリティガイド

## 📋 **セキュリティ概要**

ニュース配信システムのセキュリティ対策、脅威分析、事故対応について包括的に説明します。

### **セキュリティ方針**
- **多層防御**: 複数のセキュリティ対策を組み合わせ
- **最小権限**: 必要最小限のアクセス権限
- **継続監視**: 24時間体制での脅威監視
- **迅速対応**: セキュリティ事故への迅速な対応

---

## 🛡️ **脅威分析とリスク評価**

### **主要脅威**

| 脅威 | 影響度 | 発生確率 | リスクレベル | 対策状況 |
|------|--------|----------|--------------|----------|
| **APIキー漏洩** | 高 | 中 | 🔴 高 | ✅ 環境変数暗号化 |
| **SQLインジェクション** | 高 | 低 | 🟡 中 | ✅ パラメータ化クエリ |
| **XSS攻撃** | 中 | 低 | 🟢 低 | ✅ 入力サニタイゼーション |
| **依存関係脆弱性** | 中 | 高 | 🟡 中 | ✅ 自動スキャン |
| **不正アクセス** | 高 | 低 | 🟡 中 | ✅ アクセス制御 |
| **データ漏洩** | 高 | 低 | 🟡 中 | ✅ 暗号化保存 |

### **攻撃ベクター分析**

#### **外部攻撃**
- **Webアプリケーション攻撃**: SQLi, XSS, CSRF
- **ネットワーク攻撃**: 中間者攻撃, DNS スプーフィング
- **API攻撃**: レート制限回避, 認証バイパス

#### **内部脅威**
- **設定ミス**: 権限設定不備, 暗号化未実装
- **認証情報漏洩**: APIキー、パスワードの不適切な管理
- **依存関係リスク**: 脆弱なライブラリの使用

---

## 🔐 **認証・認可**

### **APIキー管理**

#### **安全な保存方法**
```bash
# 1. 環境変数での管理
export NEWSAPI_KEY="your-api-key-here"
export DEEPL_API_KEY="your-deepl-key-here"
export ANTHROPIC_API_KEY="your-claude-key-here"

# 2. .env ファイル (権限 600)
chmod 600 .env
cat > .env << 'EOF'
# API Keys - 絶対にGitにコミットしない
NEWSAPI_KEY=your-api-key-here
DEEPL_API_KEY=your-deepl-key-here
ANTHROPIC_API_KEY=your-claude-key-here
GMAIL_USER=your-email@gmail.com
GMAIL_APP_PASSWORD=your-app-password
EOF

# 3. 設定ファイルからの除外
echo ".env" >> .gitignore
echo "config/config.json" >> .gitignore
```

#### **APIキー検証システム**
```python
# src/security/api_validator.py
import re
import logging
from typing import Dict, Optional

class APIKeyValidator:
    """APIキー検証システム"""
    
    # APIキー形式パターン
    PATTERNS = {
        'newsapi': r'^[a-f0-9]{32}$',
        'deepl': r'^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}:fx$',
        'anthropic': r'^sk-ant-[a-zA-Z0-9\-_]{95}$',
        'gmail': r'^[a-zA-Z0-9]{16}$'  # App Password
    }
    
    @classmethod
    def validate_key(cls, service: str, api_key: str) -> bool:
        """APIキー形式検証"""
        
        if not api_key or not service:
            return False
            
        pattern = cls.PATTERNS.get(service)
        if not pattern:
            logging.warning(f"Unknown service: {service}")
            return False
            
        is_valid = bool(re.match(pattern, api_key))
        
        if not is_valid:
            logging.error(f"Invalid API key format for {service}")
            
        return is_valid
    
    @classmethod
    def mask_key(cls, api_key: str) -> str:
        """APIキーマスキング"""
        if not api_key or len(api_key) < 8:
            return "***"
            
        return api_key[:4] + "*" * (len(api_key) - 8) + api_key[-4:]
    
    @classmethod
    def check_key_strength(cls, api_key: str) -> Dict[str, bool]:
        """APIキー強度チェック"""
        
        checks = {
            'min_length': len(api_key) >= 16,
            'has_letters': bool(re.search(r'[a-zA-Z]', api_key)),
            'has_numbers': bool(re.search(r'[0-9]', api_key)),
            'has_special': bool(re.search(r'[^a-zA-Z0-9]', api_key)),
            'not_common': api_key.lower() not in ['password', 'admin', 'test']
        }
        
        return checks
```

### **アクセス制御**

#### **ファイル権限設定**
```bash
# セキュアなファイル権限設定
chmod 700 .                          # プロジェクトルート
chmod 600 .env                       # 環境変数ファイル
chmod 600 config/config.json         # 設定ファイル
chmod 755 src/                       # ソースコード
chmod 755 scripts/*.sh               # 実行スクリプト
chmod 700 backup/                    # バックアップディレクトリ
chmod 644 logs/*.log                 # ログファイル

# 所有者確認
chown -R $(whoami):$(whoami) .
```

#### **プロセス分離**
```bash
# 専用ユーザーでの実行（推奨）
sudo useradd -r -s /bin/false newsdelivery
sudo chown -R newsdelivery:newsdelivery /opt/news-delivery-system
sudo -u newsdelivery python src/main.py
```

---

## 🔒 **データ保護**

### **暗号化設定**

#### **転送中の暗号化**
```python
# src/security/encryption.py
import ssl
import aiohttp
from cryptography.fernet import Fernet

class SecureHTTPClient:
    """セキュアHTTPクライアント"""
    
    def __init__(self):
        # 強力なSSL設定
        self.ssl_context = ssl.create_default_context()
        self.ssl_context.check_hostname = True
        self.ssl_context.verify_mode = ssl.CERT_REQUIRED
        self.ssl_context.minimum_version = ssl.TLSVersion.TLSv1_2
        
        # セキュアなHTTPコネクタ
        self.connector = aiohttp.TCPConnector(
            ssl=self.ssl_context,
            limit=100,
            ttl_dns_cache=300,
            use_dns_cache=True
        )
    
    async def secure_request(self, method: str, url: str, **kwargs):
        """セキュアHTTPリクエスト"""
        
        # デフォルトヘッダー設定
        headers = kwargs.get('headers', {})
        headers.update({
            'User-Agent': 'NewsDeliverySystem/1.0',
            'Accept': 'application/json',
            'Connection': 'close'
        })
        kwargs['headers'] = headers
        
        # タイムアウト設定
        timeout = aiohttp.ClientTimeout(total=30, connect=10)
        kwargs['timeout'] = timeout
        
        async with aiohttp.ClientSession(connector=self.connector) as session:
            async with session.request(method, url, **kwargs) as response:
                return await response.json()
```

#### **保存時の暗号化**
```python
class DataEncryption:
    """データ暗号化管理"""
    
    def __init__(self, key: Optional[str] = None):
        if key:
            self.fernet = Fernet(key.encode())
        else:
            # 新しいキー生成
            key = Fernet.generate_key()
            self.fernet = Fernet(key)
            self._save_key(key)
    
    def encrypt_data(self, data: str) -> str:
        """データ暗号化"""
        return self.fernet.encrypt(data.encode()).decode()
    
    def decrypt_data(self, encrypted_data: str) -> str:
        """データ復号化"""
        return self.fernet.decrypt(encrypted_data.encode()).decode()
    
    def encrypt_file(self, file_path: str) -> str:
        """ファイル暗号化"""
        with open(file_path, 'rb') as f:
            data = f.read()
        
        encrypted_data = self.fernet.encrypt(data)
        encrypted_path = f"{file_path}.encrypted"
        
        with open(encrypted_path, 'wb') as f:
            f.write(encrypted_data)
            
        return encrypted_path
    
    def _save_key(self, key: bytes) -> None:
        """暗号化キー保存"""
        key_path = os.path.expanduser("~/.news_delivery_key")
        with open(key_path, 'wb') as f:
            f.write(key)
        os.chmod(key_path, 0o600)
```

### **機密データ処理**

#### **ログでの機密情報マスキング**
```python
# src/security/log_sanitizer.py
import re
import logging

class SecurityLogFilter(logging.Filter):
    """ログセキュリティフィルター"""
    
    # 機密情報パターン
    SENSITIVE_PATTERNS = [
        (r'(api[_-]?key["\s]*[:=]["\s]*)([a-zA-Z0-9\-_]{16,})', r'\1***'),
        (r'(password["\s]*[:=]["\s]*)([a-zA-Z0-9\-_]{8,})', r'\1***'),
        (r'(token["\s]*[:=]["\s]*)([a-zA-Z0-9\-_]{16,})', r'\1***'),
        (r'([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})', r'***@***.***'),
        (r'(sk-ant-[a-zA-Z0-9\-_]{95})', r'sk-ant-***')
    ]
    
    def filter(self, record):
        """ログメッセージのサニタイズ"""
        message = record.getMessage()
        
        for pattern, replacement in self.SENSITIVE_PATTERNS:
            message = re.sub(pattern, replacement, message, flags=re.IGNORECASE)
            
        record.msg = message
        record.args = ()
        
        return True

# ログ設定例
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)
logger.addFilter(SecurityLogFilter())
```

---

## 🔍 **脆弱性管理**

### **自動セキュリティスキャン**

#### **GitHub Actions セキュリティワークフロー**
```yaml
# .github/workflows/security-automation.yml (主要部分)
name: Security Automation

on:
  schedule:
    - cron: '0 17 * * *'  # 毎日 2:00 JST
  push:
    branches: [main]

jobs:
  security-scan:
    runs-on: ubuntu-latest
    
    steps:
    - name: 依存関係脆弱性スキャン
      run: |
        pip install safety
        safety check --json --output safety-report.json
        
    - name: コードセキュリティスキャン
      run: |
        pip install bandit
        bandit -r src/ -f json -o bandit-report.json
        
    - name: ライセンス監査
      run: |
        pip install pip-audit
        pip-audit --format=json --output=pip-audit-report.json
        
    - name: セキュリティアラート作成
      if: failure()
      uses: actions/github-script@v7
      with:
        script: |
          // セキュリティIssue自動作成
          await github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: '🚨 Security Alert - Vulnerabilities Detected',
            labels: ['security', 'priority/high', 'automated']
          });
```

#### **手動セキュリティ監査**
```bash
# 定期セキュリティ監査スクリプト
#!/bin/bash
# scripts/security_audit.sh

echo "🔒 セキュリティ監査開始..."

# 1. 依存関係脆弱性確認
echo "📦 依存関係脆弱性チェック:"
safety check --json > security-audit/safety-$(date +%Y%m%d).json
echo "結果: security-audit/safety-$(date +%Y%m%d).json"

# 2. コードセキュリティ確認
echo "🔍 コードセキュリティチェック:"
bandit -r src/ -f json -o security-audit/bandit-$(date +%Y%m%d).json
echo "結果: security-audit/bandit-$(date +%Y%m%d).json"

# 3. ファイル権限確認
echo "🔐 ファイル権限チェック:"
find . -type f -perm /o+w | grep -v ".git" > security-audit/permissions-$(date +%Y%m%d).txt
echo "結果: security-audit/permissions-$(date +%Y%m%d).txt"

# 4. 機密情報スキャン
echo "🕵️ 機密情報スキャン:"
grep -r -E "(api[_-]?key|password|secret|token)" . \
  --exclude-dir=.git \
  --exclude-dir=security-audit \
  --exclude="*.md" \
  > security-audit/secrets-scan-$(date +%Y%m%d).txt

# 5. ネットワークセキュリティ
echo "🌐 ネットワークセキュリティ:"
netstat -tuln > security-audit/network-$(date +%Y%m%d).txt

echo "🔒 セキュリティ監査完了"
echo "結果ディレクトリ: security-audit/"
```

### **脆弱性対応プロセス**

#### **緊急度分類**
- **Critical (CVSS 9.0-10.0)**: 即座対応 (2時間以内)
- **High (CVSS 7.0-8.9)**: 24時間以内対応
- **Medium (CVSS 4.0-6.9)**: 1週間以内対応
- **Low (CVSS 0.1-3.9)**: 1ヶ月以内対応

#### **対応手順**
```bash
# 1. 脆弱性詳細確認
safety check --full-report | grep -A 10 -B 5 "vulnerability"

# 2. 影響範囲分析
pip show パッケージ名
pip list | grep パッケージ名

# 3. 修正バージョン確認
pip install --upgrade パッケージ名 --dry-run

# 4. テスト環境での検証
git checkout -b security/fix-vulnerability
pip install --upgrade パッケージ名
python -m pytest tests/

# 5. 本番適用
git checkout main
git merge security/fix-vulnerability
pip install --upgrade パッケージ名

# 6. 再スキャン
safety check
bandit -r src/
```

---

## 🚨 **セキュリティ事故対応**

### **インシデント分類**

#### **レベル1 (軽微)**
- 設定ミス、軽微な脆弱性
- **対応時間**: 1営業日以内
- **対応者**: システム管理者

#### **レベル2 (重要)**
- 機密情報漏洩の可能性、中程度の脆弱性
- **対応時間**: 4時間以内
- **対応者**: セキュリティ責任者

#### **レベル3 (緊急)**
- 実際の情報漏洩、システム侵害
- **対応時間**: 1時間以内
- **対応者**: 緊急対応チーム

### **事故対応手順**

#### **初期対応 (Detection)**
```bash
# 1. 事故確認・分類
./scripts/incident_detection.sh

# 2. 影響範囲調査
grep -E "(ERROR|CRITICAL|UNAUTHORIZED)" logs/system_$(date +%Y%m).log

# 3. 緊急通知
echo "セキュリティ事故検出: $(date)" | \
mail -s "【緊急】セキュリティアラート" security@company.com

# 4. システム分離（必要に応じて）
sudo iptables -A INPUT -j DROP    # 緊急時ネットワーク遮断
```

#### **封じ込め (Containment)**
```bash
# 1. 攻撃者のアクセス遮断
sudo fail2ban-client set sshd banip 攻撃者IP

# 2. 不正プロセス停止
pkill -f "suspicious_process"

# 3. 認証情報無効化
# 全APIキーの即座無効化・再生成

# 4. バックアップから復旧準備
./scripts/prepare_emergency_restore.sh
```

#### **根絶 (Eradication)**
```bash
# 1. 脆弱性修正
pip install --upgrade 脆弱なパッケージ

# 2. 設定強化
./scripts/security_hardening.sh

# 3. 不正ファイル削除
find . -name "*.malicious" -delete

# 4. システム再構築（必要に応じて）
./scripts/system_rebuild.sh
```

#### **復旧 (Recovery)**
```bash
# 1. サービス段階的復旧
./scripts/gradual_service_recovery.sh

# 2. 監視強化
./scripts/enhanced_monitoring.sh

# 3. 動作確認
./scripts/post_incident_testing.sh

# 4. 正常性確認
./scripts/system_health_check.sh
```

#### **事後対応 (Lessons Learned)**
```bash
# 1. ログ分析・保全
./scripts/incident_log_analysis.sh

# 2. レポート作成
./scripts/generate_incident_report.sh

# 3. 改善策実装
./scripts/implement_improvements.sh

# 4. 教訓の文書化
./scripts/document_lessons_learned.sh
```

---

## 📊 **セキュリティ監視**

### **24時間監視体制**

#### **自動監視項目**
- **不正アクセス試行**: ログイン失敗、不審なIP
- **システム異常**: 高CPU、メモリ不足、ディスク満杯
- **ネットワーク異常**: 異常な通信パターン
- **ファイル変更**: 重要ファイルの予期しない変更

#### **監視スクリプト**
```bash
#!/bin/bash
# scripts/security_monitor.sh

# 24時間監視用スクリプト
while true; do
    # 不正ログイン試行チェック
    if grep -q "Authentication failure" /var/log/auth.log; then
        echo "⚠️ 不正ログイン試行検出" | \
        mail -s "セキュリティアラート" security@company.com
    fi
    
    # システムリソース監視
    CPU_USAGE=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | awk -F'%' '{print $1}')
    if (( $(echo "$CPU_USAGE > 90" | bc -l) )); then
        echo "⚠️ CPU使用率異常: ${CPU_USAGE}%" | \
        mail -s "システムアラート" admin@company.com
    fi
    
    # ファイル整合性チェック
    if ! sha256sum -c checksums.sha256 >/dev/null 2>&1; then
        echo "⚠️ ファイル整合性エラー検出" | \
        mail -s "セキュリティアラート" security@company.com
    fi
    
    sleep 300  # 5分おきに実行
done
```

### **ログ監視と分析**

#### **セキュリティログ分析**
```python
# scripts/log_analysis.py
import re
from collections import Counter
from datetime import datetime, timedelta

class SecurityLogAnalyzer:
    """セキュリティログ分析"""
    
    def __init__(self, log_file_path: str):
        self.log_file_path = log_file_path
        
    def analyze_security_events(self) -> dict:
        """セキュリティイベント分析"""
        
        events = {
            'failed_logins': 0,
            'api_errors': 0,
            'unauthorized_access': 0,
            'suspicious_ips': set(),
            'error_patterns': Counter()
        }
        
        with open(self.log_file_path, 'r') as f:
            for line in f:
                # ログイン失敗検出
                if 'Authentication failed' in line:
                    events['failed_logins'] += 1
                    
                    # IPアドレス抽出
                    ip_match = re.search(r'(\d+\.\d+\.\d+\.\d+)', line)
                    if ip_match:
                        events['suspicious_ips'].add(ip_match.group(1))
                
                # API エラー検出
                if 'API error' in line:
                    events['api_errors'] += 1
                
                # 不正アクセス検出
                if re.search(r'(403|401|unauthorized)', line, re.IGNORECASE):
                    events['unauthorized_access'] += 1
                
                # エラーパターン分析
                if 'ERROR' in line:
                    error_type = self._extract_error_type(line)
                    events['error_patterns'][error_type] += 1
        
        return events
    
    def generate_security_report(self) -> str:
        """セキュリティレポート生成"""
        events = self.analyze_security_events()
        
        report = f"""
# セキュリティ分析レポート - {datetime.now().strftime('%Y/%m/%d %H:%M')}

## 脅威指標
- ログイン失敗: {events['failed_logins']}件
- API エラー: {events['api_errors']}件  
- 不正アクセス試行: {events['unauthorized_access']}件
- 疑わしいIP: {len(events['suspicious_ips'])}個

## 疑わしいIPアドレス
{chr(10).join(f'- {ip}' for ip in events['suspicious_ips'])}

## エラーパターン（上位5件）
{chr(10).join(f'- {error}: {count}件' for error, count in events['error_patterns'].most_common(5))}

## 推奨対応
{'❌ 要注意' if events['failed_logins'] > 10 else '✅ 正常'}
"""
        return report
```

---

## 🔧 **セキュリティ設定強化**

### **システム強化スクリプト**
```bash
#!/bin/bash
# scripts/security_hardening.sh

echo "🔒 セキュリティ強化開始..."

# 1. ファイル権限強化
chmod 700 .
chmod 600 .env config/config.json
chmod 755 src/ scripts/
chmod 700 backup/
chmod -R 644 logs/

# 2. 不要ファイル削除
find . -name "*.tmp" -delete
find . -name "*.log.*" -mtime +30 -delete
find . -name ".DS_Store" -delete

# 3. SSH設定強化（サーバー管理者向け）
if [ -f /etc/ssh/sshd_config ]; then
    sudo cp /etc/ssh/sshd_config /etc/ssh/sshd_config.backup
    
    # パスワード認証無効化
    sudo sed -i 's/#PasswordAuthentication yes/PasswordAuthentication no/' /etc/ssh/sshd_config
    
    # root ログイン無効化
    sudo sed -i 's/#PermitRootLogin yes/PermitRootLogin no/' /etc/ssh/sshd_config
    
    sudo systemctl restart sshd
fi

# 4. ファイアウォール設定
if command -v ufw >/dev/null; then
    sudo ufw --force enable
    sudo ufw default deny incoming
    sudo ufw default allow outgoing
    sudo ufw allow ssh
    sudo ufw allow 443/tcp
    sudo ufw allow 80/tcp
fi

# 5. ログ監視設定
if command -v fail2ban >/dev/null; then
    sudo systemctl enable fail2ban
    sudo systemctl start fail2ban
fi

echo "🔒 セキュリティ強化完了"
```

### **定期セキュリティタスク**
```bash
# crontab に追加するセキュリティタスク

# 毎日 3:00 - セキュリティスキャン
0 3 * * * /path/to/scripts/security_audit.sh

# 毎週日曜 4:00 - 包括的セキュリティチェック
0 4 * * 0 /path/to/scripts/comprehensive_security_check.sh

# 毎月第1月曜 5:00 - ペネトレーションテスト
0 5 1-7 * 1 /path/to/scripts/penetration_test.sh

# 毎時間 - ログ監視
0 * * * * /path/to/scripts/hourly_log_monitor.sh
```

---

## 📋 **セキュリティチェックリスト**

### **日次チェック**
- [ ] システムログのセキュリティイベント確認
- [ ] API使用量の異常チェック
- [ ] ファイル整合性確認
- [ ] 不正アクセス試行の確認
- [ ] GitHub Security alerts 確認

### **週次チェック**
- [ ] 依存関係脆弱性スキャン実行
- [ ] セキュリティパッチ適用確認
- [ ] アクセス権限の見直し
- [ ] バックアップの暗号化確認
- [ ] セキュリティ設定の検証

### **月次チェック**
- [ ] 包括的セキュリティ監査
- [ ] APIキーのローテーション
- [ ] セキュリティポリシー見直し
- [ ] インシデント対応計画の確認
- [ ] セキュリティ教育・啓発

### **四半期チェック**
- [ ] ペネトレーションテスト実施
- [ ] セキュリティアーキテクチャ見直し
- [ ] 外部セキュリティ監査
- [ ] 災害復旧計画の検証
- [ ] セキュリティ投資計画の検討

---

## 📞 **セキュリティ連絡先**

### **緊急連絡先**
- **セキュリティ責任者**: security@company.com
- **システム管理者**: kensan1969@gmail.com
- **GitHub Security**: https://github.com/Kensan196948G/news-delivery-system/security

### **外部リソース**
- **JPCERT/CC**: https://www.jpcert.or.jp/
- **IPA セキュリティセンター**: https://www.ipa.go.jp/security/
- **NVD (脆弱性データベース)**: https://nvd.nist.gov/

---

**🛡️ 継続的なセキュリティ対策により、システムと情報資産を確実に保護します！**