# データベース設計書 - ニュース配信システム

**プロジェクト名:** ニュース自動配信システム  
**文書版数:** v1.0  
**作成日:** 2025年8月8日  
**最終更新:** 2025年8月8日  
**作成者:** バックエンド開発者、主任開発者  
**承認者:** CTO、プロジェクトマネージャー

---

## 1. データベース設計概要

### 1.1 設計方針
- **正規化:** 第3正規形まで適用し、データの整合性を確保
- **パフォーマンス:** 適切なインデックス設計による高速検索
- **拡張性:** 将来の機能追加に対応できる柔軟な設計
- **保守性:** わかりやすいテーブル構造とネーミング規則
- **データ整合性:** 外部キー制約とチェック制約の活用

### 1.2 データベース選択理由
- **主DB:** SQLite3 - シンプルな運用、ファイルベース、組み込み型
- **キャッシュDB:** メモリ内キャッシュ - 高速アクセス、一時的なデータ保存
- **ファイルストレージ:** ローカルファイルシステム - 記事生データ、レポートファイル

---

## 2. データベース物理設計

### 2.1 データベースファイル構成
```
E:\NewsDeliverySystem\database\
├── news.db                    # メインデータベース
├── cache.db                   # キャッシュデータベース
├── backup\                    # バックアップフォルダ
│   ├── news_20250808.db      # 日次バックアップ
│   └── news_weekly_20250808.db # 週次バックアップ
└── logs\                      # データベースログ
    └── db_operations.log      # DB操作ログ
```

### 2.2 文字エンコーディング設定
- **文字セット:** UTF-8
- **照合順序:** NOCASE（大文字小文字を区別しない）
- **日本語対応:** 全角・半角文字の適切な処理

---

## 3. テーブル設計詳細

### 3.1 メインテーブル設計

#### articles テーブル（記事情報）
```sql
CREATE TABLE articles (
    -- 主キー
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    
    -- 記事識別情報
    url TEXT UNIQUE NOT NULL,                    -- 記事URL（一意制約）
    url_hash TEXT NOT NULL,                      -- URL短縮ハッシュ
    
    -- 記事基本情報
    title TEXT NOT NULL,                         -- 原文タイトル
    content TEXT,                                -- 原文本文
    description TEXT,                            -- 記事概要
    
    -- メタデータ
    source_name TEXT,                            -- 配信元名
    author TEXT,                                 -- 著者
    published_at DATETIME,                       -- 公開日時
    collected_at DATETIME DEFAULT CURRENT_TIMESTAMP, -- 収集日時
    
    -- 言語・翻訳情報
    language TEXT DEFAULT 'en',                 -- 元言語
    translated_title TEXT,                       -- 翻訳タイトル
    translated_content TEXT,                     -- 翻訳本文
    translation_method TEXT,                     -- 翻訳手法（deepl/google）
    
    -- AI分析結果
    summary TEXT,                                -- 要約（200-250文字）
    importance_score INTEGER DEFAULT 5,         -- 重要度（1-10）
    keywords TEXT,                               -- キーワード（JSON形式）
    category TEXT,                              -- カテゴリ分類
    sentiment TEXT CHECK (sentiment IN ('positive', 'neutral', 'negative')), -- センチメント
    key_points TEXT,                            -- 重要ポイント（JSON形式）
    analysis_method TEXT DEFAULT 'claude',      -- 分析手法
    
    -- システム管理
    processed BOOLEAN DEFAULT FALSE,            -- 処理完了フラグ
    delivered BOOLEAN DEFAULT FALSE,            -- 配信完了フラグ
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- インデックス
CREATE INDEX idx_articles_published_at ON articles(published_at DESC);
CREATE INDEX idx_articles_category ON articles(category);
CREATE INDEX idx_articles_importance ON articles(importance_score DESC);
CREATE INDEX idx_articles_url_hash ON articles(url_hash);
CREATE INDEX idx_articles_source ON articles(source_name);
CREATE INDEX idx_articles_processed ON articles(processed, delivered);
CREATE INDEX idx_articles_collected_at ON articles(collected_at DESC);
```

#### delivery_history テーブル（配信履歴）
```sql
CREATE TABLE delivery_history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    
    -- 配信情報
    delivery_type TEXT NOT NULL CHECK (delivery_type IN ('scheduled', 'urgent', 'manual')),
    delivery_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    
    -- 受信者情報
    recipient_email TEXT NOT NULL,
    subject TEXT NOT NULL,
    
    -- 配信内容
    article_count INTEGER DEFAULT 0,
    categories TEXT,                            -- 含まれるカテゴリ（JSON）
    importance_summary TEXT,                    -- 重要度サマリー（JSON）
    
    -- 配信結果
    status TEXT NOT NULL CHECK (status IN ('sent', 'failed', 'pending', 'retrying')),
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    
    -- ファイルパス
    html_path TEXT,
    pdf_path TEXT,
    
    -- システム管理
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    completed_at DATETIME
);

-- インデックス
CREATE INDEX idx_delivery_time ON delivery_history(delivery_time DESC);
CREATE INDEX idx_delivery_status ON delivery_history(status);
CREATE INDEX idx_delivery_recipient ON delivery_history(recipient_email);
```

#### api_usage テーブル（API使用履歴）
```sql
CREATE TABLE api_usage (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    
    -- API情報
    api_name TEXT NOT NULL,                     -- API名（newsapi, deepl, claude等）
    endpoint TEXT,                              -- 使用エンドポイント
    
    -- 使用量情報
    request_count INTEGER DEFAULT 1,
    character_count INTEGER DEFAULT 0,         -- 文字数（翻訳API用）
    token_count INTEGER DEFAULT 0,             -- トークン数（AI API用）
    
    -- レスポンス情報
    response_status INTEGER,                    -- HTTPステータス
    response_time_ms INTEGER,                   -- レスポンス時間（ミリ秒）
    error_message TEXT,
    
    -- システム管理
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    date_key TEXT GENERATED ALWAYS AS (date(created_at)) STORED -- 日付キー
);

-- インデックス
CREATE INDEX idx_api_usage_date ON api_usage(date_key, api_name);
CREATE INDEX idx_api_usage_api ON api_usage(api_name, created_at);
CREATE INDEX idx_api_usage_status ON api_usage(response_status);
```

#### cache テーブル（キャッシュデータ）
```sql
CREATE TABLE cache (
    key TEXT PRIMARY KEY,                      -- キャッシュキー
    value TEXT NOT NULL,                       -- キャッシュ値（JSON形式）
    cache_type TEXT DEFAULT 'general',         -- キャッシュ種別
    expire_at DATETIME NOT NULL,               -- 有効期限
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    access_count INTEGER DEFAULT 0,            -- アクセス回数
    last_accessed DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- インデックス
CREATE INDEX idx_cache_expire ON cache(expire_at);
CREATE INDEX idx_cache_type ON cache(cache_type, expire_at);
CREATE INDEX idx_cache_accessed ON cache(last_accessed);
```

### 3.2 システム管理テーブル

#### system_config テーブル（システム設定）
```sql
CREATE TABLE system_config (
    key TEXT PRIMARY KEY,
    value TEXT NOT NULL,
    description TEXT,
    data_type TEXT CHECK (data_type IN ('string', 'integer', 'boolean', 'json')),
    is_encrypted BOOLEAN DEFAULT FALSE,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 初期データ
INSERT INTO system_config (key, value, description, data_type) VALUES 
('last_collection_time', '2025-08-08T00:00:00Z', '最終収集時刻', 'string'),
('system_version', '1.0.0', 'システムバージョン', 'string'),
('maintenance_mode', 'false', 'メンテナンスモード', 'boolean');
```

#### error_log テーブル（エラーログ）
```sql
CREATE TABLE error_log (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    
    -- エラー情報
    error_type TEXT NOT NULL,
    error_message TEXT NOT NULL,
    stack_trace TEXT,
    
    -- 発生コンテキスト
    module_name TEXT,
    function_name TEXT,
    line_number INTEGER,
    
    -- 追加情報
    context_data TEXT,                         -- エラー発生時のコンテキスト（JSON）
    severity TEXT CHECK (severity IN ('low', 'medium', 'high', 'critical')),
    
    -- システム情報
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    resolved_at DATETIME,
    resolution_note TEXT
);

-- インデックス
CREATE INDEX idx_error_created ON error_log(created_at DESC);
CREATE INDEX idx_error_severity ON error_log(severity, created_at DESC);
CREATE INDEX idx_error_type ON error_log(error_type);
```

---

## 4. データ関連設計

### 4.1 外部キー制約
```sql
-- delivery_historyとarticlesの関連は間接的（記事IDの配列をJSONで保存）
-- 直接的な外部キー制約は設けない（パフォーマンス考慮）
```

### 4.2 トリガー設計

#### updated_at自動更新トリガー
```sql
-- articles テーブル用
CREATE TRIGGER articles_updated_at 
    AFTER UPDATE ON articles
    FOR EACH ROW
    WHEN NEW.updated_at = OLD.updated_at
BEGIN
    UPDATE articles 
    SET updated_at = CURRENT_TIMESTAMP 
    WHERE id = NEW.id;
END;

-- system_config テーブル用
CREATE TRIGGER system_config_updated_at 
    AFTER UPDATE ON system_config
    FOR EACH ROW
BEGIN
    UPDATE system_config 
    SET updated_at = CURRENT_TIMESTAMP 
    WHERE key = NEW.key;
END;
```

#### URL重複チェックトリガー
```sql
CREATE TRIGGER check_url_duplicate 
    BEFORE INSERT ON articles
BEGIN
    SELECT CASE 
        WHEN (SELECT COUNT(*) FROM articles WHERE url = NEW.url) > 0 
        THEN RAISE(ABORT, 'Duplicate URL not allowed')
    END;
END;
```

---

## 5. データ型とサイズ制限

### 5.1 主要カラムのサイズ制限
| テーブル | カラム | データ型 | 最大サイズ | 備考 |
|----------|--------|----------|------------|------|
| articles | url | TEXT | 2000文字 | URL最大長考慮 |
| articles | title | TEXT | 500文字 | 記事タイトル |
| articles | content | TEXT | 50000文字 | 記事本文 |
| articles | summary | TEXT | 500文字 | AI要約文 |
| articles | keywords | TEXT | 1000文字 | JSON配列 |

### 5.2 JSON形式データ構造

#### keywords カラム（JSON配列）
```json
["キーワード1", "キーワード2", "キーワード3", "キーワード4", "キーワード5"]
```

#### key_points カラム（JSON配列）
```json
["重要ポイント1", "重要ポイント2", "重要ポイント3"]
```

#### categories カラム（delivery_history）
```json
{
  "domestic_social": 5,
  "international_social": 8,
  "tech": 12
}
```

---

## 6. インデックス戦略

### 6.1 パフォーマンス最適化インデックス
```sql
-- 複合インデックス
CREATE INDEX idx_articles_category_importance 
    ON articles(category, importance_score DESC, published_at DESC);

CREATE INDEX idx_articles_date_processed 
    ON articles(published_at DESC, processed, delivered);

-- 部分インデックス（条件付きインデックス）
CREATE INDEX idx_articles_unprocessed 
    ON articles(collected_at DESC) 
    WHERE processed = FALSE;

CREATE INDEX idx_articles_high_importance 
    ON articles(published_at DESC) 
    WHERE importance_score >= 8;
```

### 6.2 全文検索インデックス
```sql
-- FTSテーブルの作成（全文検索用）
CREATE VIRTUAL TABLE articles_fts USING fts5(
    title, 
    content, 
    translated_title, 
    translated_content,
    summary,
    content='articles',
    content_rowid='id'
);

-- FTSデータの同期トリガー
CREATE TRIGGER articles_fts_insert AFTER INSERT ON articles BEGIN
    INSERT INTO articles_fts(rowid, title, content, translated_title, translated_content, summary)
    VALUES (new.id, new.title, new.content, new.translated_title, new.translated_content, new.summary);
END;

CREATE TRIGGER articles_fts_delete AFTER DELETE ON articles BEGIN
    DELETE FROM articles_fts WHERE rowid = old.id;
END;

CREATE TRIGGER articles_fts_update AFTER UPDATE ON articles BEGIN
    DELETE FROM articles_fts WHERE rowid = old.id;
    INSERT INTO articles_fts(rowid, title, content, translated_title, translated_content, summary)
    VALUES (new.id, new.title, new.content, new.translated_title, new.translated_content, new.summary);
END;
```

---

## 7. データ保存・バックアップ戦略

### 7.1 データ保存場所
```
# プライマリデータ
E:\NewsDeliverySystem\database\news.db

# バックアップデータ
E:\NewsDeliverySystem\backup\
├── daily\          # 日次バックアップ（7日間保持）
├── weekly\         # 週次バックアップ（4週間保持）
└── monthly\        # 月次バックアップ（12ヶ月保持）
```

### 7.2 バックアップ実行スクリプト
```python
class DatabaseBackup:
    def __init__(self, db_path: str, backup_root: str):
        self.db_path = db_path
        self.backup_root = backup_root
        
    def daily_backup(self):
        """日次バックアップ実行"""
        date_str = datetime.now().strftime('%Y%m%d')
        backup_path = f"{self.backup_root}/daily/news_{date_str}.db"
        shutil.copy2(self.db_path, backup_path)
        
        # 7日前のバックアップを削除
        old_date = datetime.now() - timedelta(days=7)
        old_backup = f"{self.backup_root}/daily/news_{old_date.strftime('%Y%m%d')}.db"
        if os.path.exists(old_backup):
            os.remove(old_backup)
    
    def vacuum_database(self):
        """データベース最適化"""
        conn = sqlite3.connect(self.db_path)
        conn.execute('VACUUM;')
        conn.close()
```

---

## 8. データマイグレーション

### 8.1 バージョン管理
```sql
CREATE TABLE schema_version (
    version TEXT PRIMARY KEY,
    applied_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    description TEXT
);

-- 初期バージョン
INSERT INTO schema_version (version, description) 
VALUES ('1.0.0', 'Initial database schema');
```

### 8.2 マイグレーションスクリプト例
```python
class DatabaseMigration:
    def __init__(self, db_path: str):
        self.db_path = db_path
        
    def get_current_version(self) -> str:
        """現在のスキーマバージョンを取得"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute(
            "SELECT version FROM schema_version ORDER BY applied_at DESC LIMIT 1"
        )
        result = cursor.fetchone()
        conn.close()
        return result[0] if result else "0.0.0"
        
    def migrate_to_v1_1_0(self):
        """v1.1.0へのマイグレーション"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # 新しいカラムを追加
        cursor.execute("ALTER TABLE articles ADD COLUMN ai_confidence REAL DEFAULT 0.0;")
        
        # バージョン記録
        cursor.execute(
            "INSERT INTO schema_version (version, description) VALUES (?, ?)",
            ("1.1.0", "Added AI confidence score column")
        )
        
        conn.commit()
        conn.close()
```

---

## 9. パフォーマンス監視

### 9.1 クエリパフォーマンス監視
```python
class DatabaseMonitor:
    def __init__(self, db_path: str):
        self.db_path = db_path
        
    def analyze_query_performance(self):
        """クエリパフォーマンス分析"""
        conn = sqlite3.connect(self.db_path)
        
        # 実行計画の確認
        queries_to_analyze = [
            "SELECT * FROM articles WHERE category = ? ORDER BY importance_score DESC LIMIT 10",
            "SELECT COUNT(*) FROM articles WHERE published_at > ?",
            "SELECT * FROM delivery_history WHERE delivery_time > ? ORDER BY delivery_time DESC"
        ]
        
        for query in queries_to_analyze:
            explain_query = f"EXPLAIN QUERY PLAN {query}"
            cursor = conn.cursor()
            cursor.execute(explain_query, ('tech', '2025-08-01'))
            plan = cursor.fetchall()
            print(f"Query: {query}")
            print(f"Execution Plan: {plan}")
        
        conn.close()
        
    def get_database_stats(self) -> dict:
        """データベース統計情報取得"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        stats = {}
        
        # テーブルサイズ
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
        tables = cursor.fetchall()
        
        for table in tables:
            table_name = table[0]
            cursor.execute(f"SELECT COUNT(*) FROM {table_name}")
            count = cursor.fetchone()[0]
            stats[f"{table_name}_count"] = count
            
        # データベースサイズ
        cursor.execute("PRAGMA page_count")
        page_count = cursor.fetchone()[0]
        cursor.execute("PRAGMA page_size")
        page_size = cursor.fetchone()[0]
        stats['database_size_bytes'] = page_count * page_size
        
        conn.close()
        return stats
```

---

## 10. セキュリティ設計

### 10.1 データ暗号化
```python
class DataEncryption:
    def __init__(self, encryption_key: str):
        self.fernet = Fernet(encryption_key.encode())
        
    def encrypt_sensitive_data(self, data: str) -> str:
        """機密データの暗号化"""
        return self.fernet.encrypt(data.encode()).decode()
        
    def decrypt_sensitive_data(self, encrypted_data: str) -> str:
        """機密データの復号化"""
        return self.fernet.decrypt(encrypted_data.encode()).decode()
```

### 10.2 アクセス制御
```python
class DatabaseSecurity:
    def __init__(self, db_path: str):
        self.db_path = db_path
        
    def setup_database_security(self):
        """データベースセキュリティ設定"""
        # ファイル権限設定（読み書きは所有者のみ）
        os.chmod(self.db_path, 0o600)
        
        # WALモード有効化（同時アクセス改善）
        conn = sqlite3.connect(self.db_path)
        conn.execute("PRAGMA journal_mode=WAL;")
        conn.execute("PRAGMA synchronous=FULL;")
        conn.close()
```

---

## 11. 承認

### 11.1 データベース設計承認
- **バックエンド開発者:** _________________ 日付: _______
- **主任開発者:** _________________ 日付: _______  
- **CTO:** _________________ 日付: _______
- **プロジェクトマネージャー:** _________________ 日付: _______

### 11.2 変更管理
- スキーマ変更は影響度分析を実施後、段階的に適用する
- 本番環境への適用前に十分なテスト実施を必須とする
- データ移行手順は事前に検証し、ロールバック計画を準備する

---

**文書履歴:**
- v1.0 (2025/8/8): 初版作成（データベース基本設計）
- 次回レビュー予定: 2025/8/15