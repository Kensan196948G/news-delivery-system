# システム基本設計書 - ニュース自動配信システム

**プロジェクト名:** ニュース自動配信システム（News Delivery System）  
**文書版数:** v1.0  
**作成日:** 2025年8月8日  
**最終更新:** 2025年8月8日  
**作成者:** 主任開発者、バックエンド開発者  
**承認者:** CTO、プロジェクトマネージャー

---

## 1. 設計概要

### 1.1 設計方針
- **モジュラー設計:** 機能別に独立したモジュール構成
- **拡張性:** 新規ニュースソース・配信先の容易な追加
- **保守性:** 明確な責任分離とログ機能
- **信頼性:** エラーハンドリングとリトライ機能
- **性能:** 非同期処理によるパフォーマンス最適化

### 1.2 設計原則
- **単一責任の原則:** 各モジュールは単一の責任を持つ
- **依存性の逆転:** インターフェースによる疎結合
- **設定外部化:** 環境依存設定の外部ファイル化
- **ログ標準化:** 統一されたログフォーマット

---

## 2. システムアーキテクチャ

### 2.1 全体アーキテクチャ
```
┌─────────────────────────────────────────────────────────────┐
│                    ニュース自動配信システム                   │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐    │
│  │  収集層      │    │  処理層      │    │  配信層      │    │
│  │ (Collectors) │───▶│(Processors) │───▶│(Deliverers) │    │
│  └─────────────┘    └─────────────┘    └─────────────┘    │
│           │                   │                   │        │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐    │
│  │  データ層    │    │  管理層      │    │  監視層      │    │
│  │ (Database)  │    │ (Manager)   │    │ (Monitor)   │    │
│  └─────────────┘    └─────────────┘    └─────────────┘    │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 レイヤー構成

#### 2.2.1 収集層 (Collection Layer)
- **責任:** 外部ニュースソースからの記事収集
- **主要コンポーネント:** 
  - NewsAPICollector
  - NVDCollector
  - GNewsCollector
- **外部連携:** NewsAPI、NVD API、GNews API

#### 2.2.2 処理層 (Processing Layer)
- **責任:** 記事の翻訳・分析・要約処理
- **主要コンポーネント:**
  - DeepLTranslator
  - ClaudeAnalyzer
  - Deduplicator
- **外部連携:** DeepL API、Claude API

#### 2.2.3 配信層 (Delivery Layer)
- **責任:** レポート生成・メール配信
- **主要コンポーネント:**
  - HTMLReportGenerator
  - PDFReportGenerator
  - GmailSender
- **外部連携:** Gmail API

#### 2.2.4 データ層 (Data Layer)
- **責任:** データの永続化・キャッシュ管理
- **主要コンポーネント:**
  - SQLiteDatabase
  - CacheManager
  - FileManager

#### 2.2.5 管理層 (Management Layer)
- **責任:** システム全体の制御・設定管理
- **主要コンポーネント:**
  - ConfigManager
  - WorkflowManager
  - ScheduleManager

#### 2.2.6 監視層 (Monitoring Layer)
- **責任:** ログ・監視・エラー管理
- **主要コンポーネント:**
  - Logger
  - ErrorHandler
  - MetricsCollector

---

## 3. 詳細コンポーネント設計

### 3.1 メイン制御モジュール

#### main.py
```python
class NewsDeliverySystem:
    """
    メインシステム制御クラス
    全体のワークフロー制御とエラーハンドリング
    """
    def __init__(self):
        self.config = ConfigManager()
        self.logger = Logger(__name__)
        self.workflow = WorkflowManager()
        
    async def run(self) -> bool:
        """メイン実行フロー"""
        try:
            # 1. システム初期化
            await self.initialize()
            
            # 2. ニュース収集
            articles = await self.collect_news()
            
            # 3. 記事処理
            processed_articles = await self.process_articles(articles)
            
            # 4. レポート生成・配信
            await self.deliver_reports(processed_articles)
            
            return True
        except Exception as e:
            await self.handle_error(e)
            return False
```

### 3.2 収集モジュール設計

#### BaseCollector インターフェース
```python
from abc import ABC, abstractmethod
from typing import List, Dict, Optional

class BaseCollector(ABC):
    """ニュース収集の基底クラス"""
    
    @abstractmethod
    async def collect(self, category: str, count: int) -> List[Article]:
        """記事収集の実装"""
        pass
    
    @abstractmethod
    async def validate_response(self, response: Dict) -> bool:
        """レスポンス検証"""
        pass
    
    async def with_retry(self, func, max_retries: int = 3):
        """リトライ機能付き実行"""
        for attempt in range(max_retries):
            try:
                return await func()
            except Exception as e:
                if attempt == max_retries - 1:
                    raise
                await asyncio.sleep(2 ** attempt)
```

#### NewsAPICollector 実装
```python
class NewsAPICollector(BaseCollector):
    """NewsAPI専用収集クラス"""
    
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.base_url = "https://newsapi.org/v2"
        self.cache = CacheManager()
        
    async def collect(self, category: str, count: int) -> List[Article]:
        """NewsAPIからの記事収集"""
        params = self._build_params(category, count)
        response = await self._make_request(params)
        
        if await self.validate_response(response):
            return self._parse_articles(response)
        return []
    
    def _build_params(self, category: str, count: int) -> Dict:
        """APIパラメータ構築"""
        category_mapping = {
            'domestic_social': {
                'country': 'jp',
                'category': 'general'
            },
            'international_social': {
                'q': 'human rights OR social justice',
                'language': 'en'
            },
            'tech': {
                'q': 'AI OR machine learning OR cloud',
                'language': 'en'
            }
        }
        
        params = {
            'apiKey': self.api_key,
            'pageSize': count,
            'sortBy': 'publishedAt'
        }
        params.update(category_mapping.get(category, {}))
        return params
```

### 3.3 処理モジュール設計

#### 翻訳処理 (DeepLTranslator)
```python
class DeepLTranslator:
    """DeepL API翻訳処理クラス"""
    
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.base_url = "https://api-free.deepl.com/v2/translate"
        self.cache = CacheManager()
        
    async def translate_batch(self, articles: List[Article]) -> List[Article]:
        """記事のバッチ翻訳処理"""
        # 言語判定
        translation_needed = [a for a in articles if self._needs_translation(a)]
        
        # バッチサイズで分割
        batch_size = 10
        results = []
        
        for i in range(0, len(translation_needed), batch_size):
            batch = translation_needed[i:i + batch_size]
            translated_batch = await self._translate_batch(batch)
            results.extend(translated_batch)
            
        # 翻訳不要な記事と結合
        non_translation = [a for a in articles if not self._needs_translation(a)]
        return results + non_translation
    
    def _needs_translation(self, article: Article) -> bool:
        """翻訳必要性の判定"""
        # 言語検出ロジック
        return article.language != 'ja'
```

#### AI分析処理 (ClaudeAnalyzer)
```python
class ClaudeAnalyzer:
    """Claude API分析処理クラス"""
    
    def __init__(self, api_key: str):
        self.client = anthropic.Client(api_key=api_key)
        self.cache = CacheManager()
        
    async def analyze_batch(self, articles: List[Article]) -> List[Article]:
        """記事のバッチ分析処理"""
        # 重要度で優先順位付け
        sorted_articles = sorted(articles, key=self._priority_score, reverse=True)
        
        # 上位記事のみClaude分析
        high_priority = sorted_articles[:20]
        low_priority = sorted_articles[20:]
        
        # 並列分析実行
        tasks = [self.analyze_article(article) for article in high_priority]
        analyzed_high = await asyncio.gather(*tasks)
        
        # 簡易分析
        simple_analyzed = [self._simple_analyze(a) for a in low_priority]
        
        return analyzed_high + simple_analyzed
    
    async def analyze_article(self, article: Article) -> Article:
        """Claude APIによる詳細分析"""
        prompt = self._build_analysis_prompt(article)
        
        response = await self.client.messages.create(
            model="claude-3-sonnet-20240229",
            max_tokens=1000,
            messages=[{"role": "user", "content": prompt}]
        )
        
        analysis = self._parse_analysis_response(response.content[0].text)
        article.apply_analysis(analysis)
        return article
```

### 3.4 配信モジュール設計

#### HTMLレポート生成
```python
class HTMLReportGenerator:
    """HTMLレポート生成クラス"""
    
    def __init__(self, template_dir: str):
        self.env = Environment(loader=FileSystemLoader(template_dir))
        self.template = self.env.get_template('email_template.html')
        
    def generate(self, articles: List[Article], metadata: Dict) -> str:
        """HTMLレポート生成"""
        # カテゴリ別整理
        categorized = self._categorize_articles(articles)
        
        # 統計情報生成
        statistics = self._calculate_statistics(articles)
        
        # 緊急アラート抽出
        alerts = self._extract_urgent_alerts(articles)
        
        return self.template.render(
            articles=categorized,
            statistics=statistics,
            alerts=alerts,
            metadata=metadata
        )
```

#### Gmail配信処理
```python
class GmailSender:
    """Gmail API配信処理クラス"""
    
    def __init__(self, credentials_path: str):
        self.service = self._build_service(credentials_path)
        
    async def send_report(
        self, 
        recipient: str, 
        subject: str, 
        html_content: str,
        pdf_attachment: Optional[str] = None
    ) -> bool:
        """レポートメール送信"""
        message = self._create_message(
            recipient, subject, html_content, pdf_attachment
        )
        
        try:
            result = await self._send_message(message)
            self._log_delivery_success(recipient, result)
            return True
        except Exception as e:
            self._log_delivery_error(recipient, e)
            return False
```

---

## 4. データ設計

### 4.1 記事データモデル
```python
@dataclass
class Article:
    """記事データモデル"""
    url: str
    title: str
    content: str
    description: Optional[str] = None
    
    # メタデータ
    source_name: str = ""
    author: Optional[str] = None
    published_at: datetime = None
    collected_at: datetime = field(default_factory=datetime.now)
    
    # 翻訳関連
    language: str = "en"
    translated_title: Optional[str] = None
    translated_content: Optional[str] = None
    
    # 分析結果
    summary: Optional[str] = None
    importance_score: int = 5
    keywords: List[str] = field(default_factory=list)
    category: Optional[str] = None
    sentiment: Optional[str] = None
    
    def apply_analysis(self, analysis: Dict):
        """分析結果の適用"""
        self.summary = analysis.get('summary')
        self.importance_score = analysis.get('importance_score', 5)
        self.keywords = analysis.get('keywords', [])
        self.category = analysis.get('category')
        self.sentiment = analysis.get('sentiment')
```

### 4.2 データベーススキーマ
```sql
-- 記事テーブル
CREATE TABLE articles (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    url TEXT UNIQUE NOT NULL,
    url_hash TEXT NOT NULL,
    title TEXT NOT NULL,
    content TEXT,
    description TEXT,
    
    -- メタデータ
    source_name TEXT,
    author TEXT,
    published_at DATETIME,
    collected_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    
    -- 翻訳
    language TEXT DEFAULT 'en',
    translated_title TEXT,
    translated_content TEXT,
    
    -- 分析結果
    summary TEXT,
    importance_score INTEGER DEFAULT 5,
    keywords TEXT, -- JSON形式
    category TEXT,
    sentiment TEXT,
    
    -- システム
    processed BOOLEAN DEFAULT FALSE,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- インデックス
CREATE INDEX idx_published_at ON articles(published_at);
CREATE INDEX idx_category ON articles(category);
CREATE INDEX idx_importance ON articles(importance_score);
CREATE INDEX idx_url_hash ON articles(url_hash);
CREATE UNIQUE INDEX idx_url ON articles(url);
```

---

## 5. 外部インターフェース設計

### 5.1 APIクライアント設計

#### 共通APIクライアント
```python
class APIClient:
    """共通API通信クライアント"""
    
    def __init__(self, base_url: str, api_key: str):
        self.base_url = base_url
        self.api_key = api_key
        self.session = aiohttp.ClientSession()
        self.rate_limiter = RateLimiter()
        
    async def make_request(
        self, 
        method: str, 
        endpoint: str, 
        params: Dict = None,
        data: Dict = None,
        headers: Dict = None
    ) -> Dict:
        """API リクエスト実行"""
        await self.rate_limiter.acquire()
        
        full_url = f"{self.base_url}/{endpoint}"
        default_headers = self._get_default_headers()
        if headers:
            default_headers.update(headers)
            
        async with self.session.request(
            method, full_url, 
            params=params, 
            json=data,
            headers=default_headers
        ) as response:
            if response.status == 200:
                return await response.json()
            else:
                raise APIError(f"API request failed: {response.status}")
```

### 5.2 レート制限管理
```python
class RateLimiter:
    """APIレート制限管理"""
    
    def __init__(self):
        self.limits = {
            'newsapi': {'requests': 1000, 'window': 86400},  # 1日1000件
            'deepl': {'chars': 500000, 'window': 2592000},   # 月50万文字
            'claude': {'requests': 1000, 'window': 86400}    # 1日1000件
        }
        self.usage = defaultdict(list)
        
    async def acquire(self, service: str = 'default'):
        """レート制限チェック"""
        if service in self.limits:
            current_usage = self._get_current_usage(service)
            limit = self.limits[service]
            
            if current_usage >= limit['requests']:
                wait_time = self._calculate_wait_time(service)
                await asyncio.sleep(wait_time)
                
    def _get_current_usage(self, service: str) -> int:
        """現在の使用量取得"""
        now = time.time()
        window = self.limits[service]['window']
        cutoff = now - window
        
        # 古い記録を削除
        self.usage[service] = [
            timestamp for timestamp in self.usage[service] 
            if timestamp > cutoff
        ]
        
        return len(self.usage[service])
```

---

## 6. エラーハンドリング設計

### 6.1 例外クラス階層
```python
class NewsSystemException(Exception):
    """システム共通例外基底クラス"""
    pass

class CollectionError(NewsSystemException):
    """記事収集エラー"""
    pass

class TranslationError(NewsSystemException):
    """翻訳処理エラー"""
    pass

class AnalysisError(NewsSystemException):
    """分析処理エラー"""
    pass

class DeliveryError(NewsSystemException):
    """配信エラー"""
    pass

class APIError(NewsSystemException):
    """外部API通信エラー"""
    def __init__(self, message: str, status_code: int = None):
        super().__init__(message)
        self.status_code = status_code
```

### 6.2 エラーハンドリング戦略
```python
class ErrorHandler:
    """エラーハンドリング管理クラス"""
    
    def __init__(self, logger: Logger):
        self.logger = logger
        self.error_stats = defaultdict(int)
        
    async def handle_error(self, error: Exception, context: Dict = None):
        """エラー処理統括"""
        error_type = type(error).__name__
        self.error_stats[error_type] += 1
        
        # ログ記録
        self.logger.error(
            f"Error occurred: {error_type}", 
            extra={
                'error_message': str(error),
                'context': context or {},
                'stack_trace': traceback.format_exc()
            }
        )
        
        # エラー種別ごとの対応
        if isinstance(error, APIError):
            await self._handle_api_error(error, context)
        elif isinstance(error, CollectionError):
            await self._handle_collection_error(error, context)
        elif isinstance(error, DeliveryError):
            await self._handle_delivery_error(error, context)
            
    async def _handle_api_error(self, error: APIError, context: Dict):
        """API エラー個別対応"""
        if error.status_code == 429:  # Rate limit exceeded
            # レート制限対応
            await self._handle_rate_limit(context)
        elif error.status_code == 401:  # Unauthorized
            # 認証エラー通知
            await self._notify_auth_error(context)
```

---

## 7. 設定管理設計

### 7.1 設定階層構造
```python
class ConfigManager:
    """設定管理クラス"""
    
    def __init__(self, config_path: str = "config/config.json"):
        self.config_path = config_path
        self.config = self._load_config()
        self.env_vars = self._load_env_vars()
        
    def _load_config(self) -> Dict:
        """設定ファイル読み込み"""
        with open(self.config_path, 'r', encoding='utf-8') as f:
            return json.load(f)
            
    def get(self, key: str, default=None):
        """設定値取得（環境変数 > config.json > default の順）"""
        # 環境変数をチェック
        env_key = key.upper().replace('.', '_')
        if env_key in os.environ:
            return os.environ[env_key]
            
        # config.json をチェック
        keys = key.split('.')
        value = self.config
        for k in keys:
            if isinstance(value, dict) and k in value:
                value = value[k]
            else:
                return default
        return value
```

### 7.2 設定項目構造
```json
{
  "system": {
    "version": "1.0.0",
    "timezone": "Asia/Tokyo",
    "debug_mode": false
  },
  "collection": {
    "batch_size": 50,
    "retry_attempts": 3,
    "timeout_seconds": 30,
    "categories": {
      "domestic_social": {
        "enabled": true,
        "count": 10,
        "priority": 1
      }
    }
  },
  "processing": {
    "translation": {
      "batch_size": 10,
      "cache_ttl": 86400
    },
    "analysis": {
      "max_concurrent": 5,
      "cache_ttl": 604800
    }
  },
  "delivery": {
    "schedule": ["07:00", "12:00", "18:00"],
    "recipients": ["admin@example.com"],
    "emergency_threshold": 9
  }
}
```

---

## 8. パフォーマンス設計

### 8.1 非同期処理設計
```python
class WorkflowManager:
    """ワークフロー管理クラス"""
    
    def __init__(self, max_concurrent: int = 10):
        self.semaphore = asyncio.Semaphore(max_concurrent)
        self.task_queue = asyncio.Queue()
        
    async def execute_parallel(
        self, 
        tasks: List[Callable], 
        max_concurrent: int = None
    ) -> List:
        """並列処理実行"""
        if max_concurrent:
            semaphore = asyncio.Semaphore(max_concurrent)
        else:
            semaphore = self.semaphore
            
        async def _execute_with_semaphore(task):
            async with semaphore:
                return await task()
                
        return await asyncio.gather(*[
            _execute_with_semaphore(task) for task in tasks
        ])
```

### 8.2 キャッシュ戦略
```python
class CacheManager:
    """キャッシュ管理クラス"""
    
    def __init__(self):
        self.memory_cache = {}
        self.db_cache = SQLiteCache()
        
    async def get(self, key: str, cache_type: str = "memory") -> Optional[Any]:
        """キャッシュデータ取得"""
        if cache_type == "memory":
            return self.memory_cache.get(key)
        elif cache_type == "persistent":
            return await self.db_cache.get(key)
            
    async def set(
        self, 
        key: str, 
        value: Any, 
        ttl: int = 3600,
        cache_type: str = "memory"
    ):
        """キャッシュデータ保存"""
        if cache_type == "memory":
            self.memory_cache[key] = {
                'value': value,
                'expires_at': time.time() + ttl
            }
        elif cache_type == "persistent":
            await self.db_cache.set(key, value, ttl)
```

---

## 9. 承認

### 9.1 設計承認
- **主任開発者:** _________________ 日付: _______
- **CTO:** _________________ 日付: _______
- **プロジェクトマネージャー:** _________________ 日付: _______

### 9.2 変更管理
- 設計変更は変更管理プロセスに従って実施する
- 影響度分析を実施し、関係者の承認を得る
- 詳細設計書との整合性を保つ

---

**文書履歴:**
- v1.0 (2025/8/8): 初版作成（システム基本設計）
- 次回レビュー予定: 2025/8/15